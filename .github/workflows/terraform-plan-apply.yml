name: "[CI] Deploy Terraform stacks"
on:
  workflow_call:
    inputs:
      environment_name:
        required: false
        default: dev
        type: string
      aws_region:
        required: false
        default: eu-west-2
        type: string
      execute_terraform_plan:
        required: false
        type: boolean
        default: false
        description: "Whether or not to execute the Terraform plan. Set to false to plan only."
      python_version:
        required: false
        type: string
        default: "3.12"
        description: "The version of python required when building packages via Terraform"
      repo:
        required: false
        type: string
        default: ${{ github.repository }}
        description: "Specify the org/repo of the repo containing Terraform code. Normally left blank to clone calling repo."
      ref:
        required: false
        type: string
        default: ${{ github.ref }}
        description: "Specify the branch of the Terraform code. Normally left blank to use calling ref."
      artefact_path:
        required: false
        type: string
        default: "nonexistentfile.txt"
        description: "If there are artefacts created from data sources, specify the path here so they are downloaded before applying"
      terraform_arg_refresh:
        required: false
        description: "Whether or not to refresh Terraform state when running Terraform commands. Should be 'true' (string, not boolean) for scheduled drift detection workflows."
        type: string
        default: "false"
  
    secrets:
      AWS_ROLE_NAME:
        required: false
      AWS_ACCOUNT_ID:
        required: false
      AWS_ACCESS_KEY_ID:
        required: false
      AWS_SECRET_ACCESS_KEY:
        required: false
      AZURE_SUBSCRIPTION_ID:
        required: false
      AZURE_TENANT_ID:
        required: false
      AZURE_CLIENT_ID:
        required: false
      AZURE_RESOURCE_GROUP_NAME:
        required: false
      TF_MODULES_SSH_DEPLOY_KEY:
        required: false
        description: "The SSH key used to clone Terraform modules downloaded as part of the Terraform init"
      REPO_SSH_DEPLOY_KEY:
        required: false
        description: "The SSH key used to checkout private remote repos"
      SSH_DEPLOY_KEY:
        required: false
        description: "Deprecated: Use either TF_MODULES_SSH_DEPLOY_KEY or REPO_SSH_DEPLOY_KEY instead."
      TF_PLAN_ENCRYPTION_PASSPHRASE:
        required: true
        description: "The passphrase used to encrypt Terraform Plans before uploading them as Github Artifacts"
  
        
jobs:
  define_matrix:
    name: Define directory matrix for build
    runs-on: ubuntu-latest
    outputs:
      stack_config: "${{ steps.stack_config.outputs.json_directory_list }}"
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ inputs.ref }}
          ssh-key: ${{ secrets.REPO_SSH_DEPLOY_KEY }}

      - name: Determine order to run Terraform stacks
        uses: >-
          ukhsa-collaboration/devops-github-actions/.github/actions/terraform-dependency-sort@dea5f8f73cde1ca4bbd2a29b6b59bd8264af27f8
        id: stack_config

  filter_matrix:
    name: Filter Stacks
    needs:
      - define_matrix
    runs-on: ubuntu-latest
    outputs:
      empty_deps: ${{ steps.filter_matrix.outputs.empty_deps }}
      non_empty_deps: ${{ steps.filter_matrix.outputs.non_empty_deps }}
      combined_stacks: ${{ steps.filter_matrix.outputs.combined_stacks }}
    steps:
      - name: Filter Stacks
        env:
          ENVIRONMENT_NAME: ${{ inputs.environment_name }}
        id: filter_matrix
        run: |
          echo '${{ needs.define_matrix.outputs.stack_config }}' > initial_matrix.json

          # Filter the matrix to only include stacks with planned changes.
          # Additionally, if the runner_label is "self-hosted", append the environment name.
          # TODO: Find out how a stack could possibly have any planned changed at all - we haven't even
          # run terraform init yet!
          filtered_matrix=$(jq -c --arg env_name "${ENVIRONMENT_NAME}" '
            [ .[]
              | select(.planned_changes == true)
              | if .runner_label == "self-hosted"
                  then .runner_label = ["self-hosted", $env_name]
                  else .
                end
            ]
          ' initial_matrix.json)
          echo "Filtered Matrix: $filtered_matrix"

          # Split the filtered matrix into two groups based on dependencies so that we can run 
          # Terraform stacks that don't have dependencies in a seperate job to those that do.
          empty_deps=$(echo "$filtered_matrix" | jq -c '[.[] | select((.dependencies | length) == 0)]')
          non_empty_deps=$(echo "$filtered_matrix" | jq -c '[.[] | select((.dependencies | length) > 0)]')

          combined_stacks=$(echo "$empty_deps $non_empty_deps" | jq -c -s add)

          echo "DEBUG: Filtered Matrix - Combined stacks: $combined_stacks"
          echo "DEBUG: Filtered Matrix - Stacks without dependencies: $empty_deps"
          echo "DEBUG: Filtered Matrix - Stacks with dependencies: $non_empty_deps"

          echo "empty_deps=$empty_deps" >> $GITHUB_OUTPUT
          echo "non_empty_deps=$non_empty_deps" >> $GITHUB_OUTPUT
          echo "combined_stacks=$combined_stacks" >> $GITHUB_OUTPUT

  
  check:
    name: Lint and SAST Scan Terraform code
    uses: ./.github/workflows/terraform-code-check.yml
    with:
      repo: ${{ inputs.repo }}
      ref: ${{ inputs.ref }}
    secrets:
      REPO_SSH_DEPLOY_KEY: ${{ secrets.REPO_SSH_DEPLOY_KEY }}

  # Since we cannot guarantee that the first plan_apply_with_deps won't depend on something in plan_apply_no_deps, we apply 
  # the stacks without dependencies first in parallel and then apply the stacks with dependencies serially.
  plan_apply_no_deps:
    name: Plan and Apply Terraform (Stacks with no dependencies)
    uses: ./.github/workflows/terraform-core.yml
    needs:
      - check
      - filter_matrix
    with:
      environment_name: ${{ inputs.environment_name }}
      aws_region: ${{ inputs.aws_region }}
      repo: ${{ inputs.repo }}
      ref:  ${{ inputs.ref }}
      stack_config: "${{ needs.filter_matrix.outputs.empty_deps }}"
      terraform_action: "apply"
      execute_terraform_plan: ${{ inputs.execute_terraform_plan }}
      upload_plan: true
      python_version: ${{ inputs.python_version }}
      artefact_path: ${{ inputs.artefact_path }}
      terraform_arg_refresh: ${{ inputs.terraform_arg_refresh }}
      max_parallel: 5
    secrets: inherit
    
  plan_apply_with_deps:
    name: Plan and Apply Terraform (Stacks with dependencies)
    uses: ./.github/workflows/terraform-core.yml
    needs:
      - check
      - filter_matrix
      - plan_apply_no_deps
    with:
      environment_name: ${{ inputs.environment_name }}
      aws_region: ${{ inputs.aws_region }}
      repo: ${{ inputs.repo }}
      ref:  ${{ inputs.ref }}
      stack_config: "${{ needs.filter_matrix.outputs.non_empty_deps }}"
      terraform_action: "apply"
      execute_terraform_plan: ${{ inputs.execute_terraform_plan }}
      upload_plan: true
      python_version: ${{ inputs.python_version }}
      terraform_arg_refresh: ${{ inputs.terraform_arg_refresh }}
      artefact_path: ${{ inputs.artefact_path }}
    secrets: inherit
  
  post-deployment-qa-checks:
    name: Run post deployment QA checks.
    uses: ./.github/workflows/terraform-post-deployment-qa.yml
    needs: 
      - plan_apply_with_deps
      - plan_apply_no_deps
      - filter_matrix
    with:
      environment_name: ${{ inputs.environment_name }}
      aws_region: ${{ inputs.aws_region }}
      stack_config: "${{ needs.filter_matrix.outputs.combined_stacks }}"
    secrets: inherit
